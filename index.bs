<pre class="metadata">
Title: Streaming MediaStreams
Shortname: streaming-mediastreams
Repository: domenic/streaming-mediastreams
Inline Github Issues: true
Status: DREAM
Boilerplate: omit conformance, omit feedback-header
Editor: Domenic Denicola, Google https://www.google.com/, d@domenic.me, https://domenic.me/
Abstract: This specification allows the creation of a readable stream derived from a MediaStream object, to allow
Abstract: recording or other direct manipulation of the MediaStream's contents.
Default Biblio Status: current
!Participate: <a href="https://github.com/domenic/streaming-mediastreams">GitHub domenic/streaming-mediastreams</a> (<a href="https://github.com/domenic/streaming-mediastreams/issues/new">new issue</a>, <a href="https://github.com/domenic/streaming-mediastreams/issues?state=open">open issues</a>)
!Participate: <a href="https://wiki.whatwg.org/wiki/IRC">IRC: #whatwg on Freenode</a>
!Commits: <a href="https://github.com/domenic/streaming-mediastreams/commits">https://github.com/domenic/streaming-mediastreams/commits</a>
</pre>

<style>
/* hide ugly stuff that is moved to the acks */
[data-fill-with="spec-metadata"] .editor {
    display: none;
}

[data-fill-with="copyright"] {
    display: none;
}
</style>

<script src="https://resources.whatwg.org/file-issue.js" async></script>


<h2 id="intro">Introduction</h2>

<em>This section is non-normative.</em>

{{MediaStream}} objects act as opaque handles to a stream of audio and video data. These can be consumed in a variety of ways by various platform APIs, as defined in [[GETUSERMEDIA]]. This specification defines a way of consuming them by creating a <a>readable stream</a>, whose <a>chunks</a> are {{Blob}}s of encoded audio/video data recorded from the stream.

The resulting readable stream, known as a <code>MediaStream</code> recorder and embodied by the {{MediaStreamRecorder}} interface, can then be read from directly by author code which wishes to manipulate these blobs. Alternately, it may be <a>piped</a> to another destination, or consumed by other code that takes a readable stream.

<h2 id="examples">Example Usage</h2>

<em>This section is non-normative.</em>

To read six seconds of audio-video input from a user's webcam as a single {{Blob}}, the following code could be used:

<pre><code class="lang-javascript">
function getSixSecondsOfVideo() {
  navigator.mediaDevices.getUserMedia({ video: true }).then(mediaStream => {
    const recorder = new MediaStreamRecorder(mediaStream, { timeSlice: 6 * 1000 });
    const reader = recorder.getReader();

    return reader.read().then(({ value }) => {
      reader.cancel();
      return value;
    });
  });
}

getSixSecondsOfVideo().then(blob => ...);
</code></pre>

This uses the <code>timeSlice</code> option to ensure that each chunk read from the {{MediaStreamRecorder}} is at least six seconds long. Upon receiving the first chunk, it immediately cancels the readable stream, as no more recording is necessary.

If the ultimate destination for the streaming audio-video input were somewhere else, say an [[INDEXEDDB]] database, then it would be more prudent to let the user agent choose the time slice, and to store the chunks as they are available:

<pre><code class="lang-javascript">
navigator.mediaDevices.getUserMedia({ video: true }).then(mediaStream => {
  const recorder = new MediaStreamRecorder(mediaStream);
  writeReadableStreamToIndexedDB(recorder);
});

let startTime;

function writeReadableStreamToIndexedDBForSixSeconds(rs) {
  const reader = rs.getReader();
  startTime = Date.now();
  return pump();

  function pump() {
    return reader.read().then(({ value }) => {
      writeBlobToIndexedDB(value); // gory details omitted

      if (Date.now() - startTime > 6 * 1000) {
        reader.cancel();
      } else {
        return pump();
      }
    });
  }
}
</code></pre>

If you were writing to a destination which had a proper <a>writable stream</a> representing it, this would of course become much easier:

<pre><code class="lang-javascript">
navigator.mediaDevices.getUserMedia({ video: true }).then(mediaStream => {
  startTime = Date.now();
  const recorder = new MediaStreamRecorder(mediaStream);

  const piping = recorder.pipeTo(someWritableStream);
  setTimeout(() => piping.cancel(), 6 * 1000); // XXX depends on cancelable promises
});
</code></pre>


<h2 id="media-stream-recorder">The <code>MediaStreamRecorder</code> API</h2>

<pre class="idl">
[Constructor(MediaStream stream, optional MediaStreamRecorderOptions options)]
interface MediaStreamRecorder : ReadableStream {
  readonly attribute MediaStream mediaStream;
  readonly attribute DOMString mimeType;
  readonly attribute boolean ignoreMutedMedia;
  readonly attribute unsigned long long timeSlice;
  readonly attribute unsigned long long bitRate;

  static CanPlayTypeResult canRecord(DOMString mimeType);
};

dictionary MediaStreamRecorderOptions {
  DOMString mimeType;
  boolean ignoreMutedMedia = false;
  [EnforceRange] unsigned long long timeSlice = 0;
  [EnforceRange] unsigned long long bitRate;
};
</pre>

All {{MediaStreamRecorder}} instances have \[[mediaStream]], \[[mimeType]], \[[ignoreMutedMedia]], \[[timeSlice]], and \[[bitRate]] internal slots.

<h3 id="msr-constructor">new MediaStreamRecorder(stream, options)</h3>

1. If <code>options.mimeType</code> is not a supported MIME type for media stream recording, throw a {{NotSupportedError}} DOMException.
1. Set this@\[[mediaStream]] to <code>mediaStream</code>.
1. Set this@\[[mimeType]] to <code>options.mimeType</code>.
1. Set this@\[[ignoreMutedMedia]] to <code>options.ignoreMutedMedia</code>.
1. Set this@\[[timeSlice]] to the greater of <code>options.timeSlice</code> and some minimum recording time slice imposed by the user agent.
1. If <code>options.bitRate</code> is present, set this@\[[bitRate]] to <code>options.bitRate</code>, clamped within a range deemed acceptable by the user agent. Otherwise, set this@\[[bitRate]] to a default bit rate, perhaps dependent on this@\[[mimeType]] or this@\[[timeSlice]].
1. TODO: the actually interesting stuff.

<h3 id="msr-media-stream">get MediaStreamRecorder.prototype.mediaStream</h3>

1. Return this@\[[mediaStream]].

<h3 id="msr-mime-type">get MediaStreamRecorder.prototype.mimeType</h3>

1. Return this@\[[mimeType]].

<h3 id="msr-ignore-muted-media">get MediaStreamRecorder.prototype.ignoreMutedMedia</h3>

1. Return this@\[[ignoreMutedMedia]].

<h3 id="msr-time-slice">get MediaStreamRecorder.prototype.timeSlice</h3>

1. Return this@\[[timeSlice]].

<h3 id="msr-bit-rate">get MediaStreamRecorder.prototype.bitRate</h3>

1. Return this@\[[bitRate]].


<h3 id="msr-can-record">MediaStreamRecorder.canRecord(mimeType)</h3>

1. If the user agent knows that it cannot record <code>mimeType</code>, return <code>""</code>.
1. If the user agent is confident that it can record <code>mimeType</code>, return <code>"probably"</code>.
1. Return <code>"maybe"</code>.

<div class="note">
    Implementers are encouraged to return <code>"maybe"</code> unless the type can be confidently established as being
    supported or not.
</div>

<h2 id="acks" class="no-num">Acknowledgments</h2>

The editor would like to thank
(nobody yet)
for their contributions to this specification.

This standard is written by <a href="https://domenic.me/">Domenic Denicola</a> (<a href="https://google.com">Google</a>, <a href="mailto:d@domenic.me">d@domenic.me</a>).

Per <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0</a>, to the extent possible under law, the editor has waived all copyright and related or neighboring rights to this work.

<pre class="anchors">
url: https://w3c.github.io/mediacapture-main/#idl-def-MediaStream; type: interface
    text: MediaStream
urlPrefix: https://streams.spec.whatwg.org/; spec: STREAMS
    text: ReadableStream; url: #rs-class; type: interface
    type: dfn
        text: readable stream
        text: writable stream
        text: chunk
        text: pipe; url: #piping
urlPrefix: https://heycam.github.io/webidl/; type: exception; spec: WEBIDL
    text: NotSupportedError
url: https://w3c.github.io/FileAPI/#dfn-Blob; type: interface
    text: Blob
</pre>
